:toc: macro
toc::[]

= Testing with OASP4J

Testing our applications is one of the most important parts of the development. The _Oasp4j_ documentation provides a detailed information about the https://github.com/oasp/oasp4j/wiki/guide-testing[testing principles]. In addition to that, in both the DevonfwGuide.pdf (_Write Unit Test Cases_) and in the https://github.com/devonfw/devon/wiki/getting-started-writing-unittest-cases[Devon documentation] you can find information about testing explained, on a more practical way.

In this chapter we are going to focus on showing some test examples, and explain briefly how to start testing our _Oasp4j_ apps.

== My Thai Star testing example

In all the _Oasp4j_ projects (based on _Maven_ and _Spring_) we are going to find a dedicated package for testing.

image::images/oasp4j/8.Testing/mythaistar_testing_structure.png[width="250", link="images/oasp4j/8.Testing/mythaistar_testing_structure.png"]

In addition to this the testing part of the project has also its own _resources_ package, so we are going to be able to configure the application properties or other resources to create specific testing scenarios.

We should incorporate the https://en.wikipedia.org/wiki/Unit_testing[unit test] as one of the main efforts during the development, considering even approaches like https://martinfowler.com/bliki/TestDrivenDevelopment.html[TDD].

The tests in our applications should cover a significant amount of functionality, however in this part of the tutorial we are going to focus in the test of our _Oasp4j_ components.

As you have seen in the previous snapshot, each component of our application should have a dedicated package for testing in the test _package_. Inside each testing package we will create the related test classes that should follow the naming convention

----
[Component]Test.java
----

This is because we are going to use _Maven_ to launch the tests of our application and _Maven_ will look for test classes that end with _Test_ word.

Testing with _Oasp4j_ means that we have already available _Spring Test_ and _Oasp4j_ test module which means that we will find a significant amount of annotations and implementations that are going to provide us with all the needed libraries and tools to create tests in a really simply way.

Focusing on the components test means that we are going to test the implementation of the logic layer of our applications. Because of this, you can see in our test structure that our test classes are inside the `[component].logic.impl` package.

If we open one of the test classes we will find something like this

[source,java]
----
@SpringApplicationConfiguration(classes = SpringBootApp.class)
@WebAppConfiguration
public class DishmanagementTest extends ComponentTest {

  @Inject
  private Dishmanagement dishmanagement;

  @Test
  public void findAllDishes() {

    DishSearchCriteriaTo criteria = new DishSearchCriteriaTo();
    List<CategoryEto> categories = new ArrayList<>();
    criteria.setCategories(categories);
    PaginatedListTo<DishCto> result = this.dishmanagement.findDishCtos(criteria);
    assertThat(result).isNotNull();
  }
  ...

}
----

- `@SpringApplicationConfiguration` and `@WebAppConfiguration` are _Spring Test_ annotations to load the context of our application. So we will have the application running like in a _real_ situation.

- extending the _Oasp4j_ test class `ComponentTest` will inject in our test class functionalities like http://joel-costigliola.github.io/assertj/[Assertions]

- _Spring Test_ gives us the option for dependency injection, so we are going to be able to `@Inject` our components to test them.

- Finally with the `@Test` annotation we can declare a test to be executed during testing process.


== Testing our application

Now that we have briefly overview we are going to add some tests to our _Jump the Queue_ application.

We have a main component for managing _visitors_, so we are going to create a dedicated package for the component within the general testing package. And inside this new package we are going to add a new test class named `VisitormanagementTest.java`

image::images/oasp4j/8.Testing/jumpthequeue_testing_structure.png[width="250", link="images/oasp4j/8.Testing/jumpthequeue_testing_structure.png"]

[NOTE]
====
You can see that we already have some test packages in the `src/test/java/com.cap.jumpthequeue.general` package. Those tests are from the _Oasp4j_ archetype and we can use them as model for some tests in our apps. 
====

In the `VisitormanagementTest` class we are going to add the annotations to run the app context when executing the tests, extend the `ComponentTest` class to obtain the assertions and inject our `visitormanagement` component.

[source,java]
----
import org.springframework.boot.test.SpringApplicationConfiguration;
import org.springframework.test.context.web.WebAppConfiguration;
import com.cap.jumpthequeue.SpringBootApp;
import io.oasp.module.test.common.base.ComponentTest;

@SpringApplicationConfiguration(classes = SpringBootApp.class)
@WebAppConfiguration
public class VisitormanagementTest extends ComponentTest {
  @Inject
  private Visitormanagement visitormanagement;
}
----

Now we can start adding our first test. In link:JumpTheQueueDesign[Jump the Queue] we have two main functionalities:

- register a visitor returning an _access code_.

- list the current visitors.

Let's add a test to check the first one.

We are going to create a method called _registerVisitorTest_ and we are going to add the `@Test` annotation.

Inside this test we are going to verify the registration process of our app. To do so we only need to call the _registerVisitor_ method of the component and provide a _VisitorEto_ object. After the method is called we are going the check the response of the method to verify that the expected business logic has been executed successfully.

[source,java]
----
  @Test
  public void registerVisitorTest() {

    VisitorEto visitor = new VisitorEto();
    visitor.setName("Mary");
    visitor.setEmail("mary@mail.com");
    visitor.setPhone("123456789");
    VisitorCto result = this.visitormanagement.registerVisitor(visitor);
    assertThat(result).isNotNull();
  }
----

[NOTE]
====
Have you noticed that the _mock_ data of the test is the same data that we have used in previous chapters for the manual verification of our services? Exactly, from now on this test will allow us to automate the manual verification process.
====

Now is the moment for running the test. We can do it in several ways but to simplify the example just right click over the method and select _Run as > JUnit Test_

image::images/oasp4j/8.Testing/jumpthequeue_testing_runtest.png[ link="images/oasp4j/8.Testing/jumpthequeue_testing_runtest.png"]

[NOTE]
====
We can also debug our tests using the _Debug As > JUnit Test_ option.
====

The result of the test will be shown in the _JUnit_ tab of Eclipse

image::images/oasp4j/8.Testing/jumpthequeue_testing_result.png[ link="images/oasp4j/8.Testing/jumpthequeue_testing_result.png"]

Seems that everything went ok, our register process passes the test. Let's complete the test checking if the just created user is _"Mary"_ and if the _access code_ has been provided.

We can do it simply adding more _asserts_ to check the _result_ object

[source,java]
----
assertThat(result.getVisitor().getName()).isEqualTo("Mary");
assertThat(result.getCode().getCode()).isNotEmpty();
----

Now running again the test we should obtain the expected result

image::images/oasp4j/8.Testing/jumpthequeue_testing_result2.png[ link="images/oasp4j/8.Testing/jumpthequeue_testing_result2.png"]

We could even test the failure of a test as the expected behavior of our application. Remember the validations we introduced in the link:Oasp4jValidations[previous chapter]? We can test expected errors if the visitor's data is incorrect