:toc: macro
toc::[]

= Components

== OASP4j Components

image::images/oasp4j/4.Components/oasp4j_architecture.png[width="450", link="images/oasp4j/4.Components/oasp4j_architecture.png"]

When working with _Oasp4j_ the recommended approach for the design of the applications is the _Component Oriented Design_. Each component will represent a significant part (or feature) of our application related to _CRUD_ operations. Internally, the components will be divided in three layers (_service_, _logic_, and _dataaccess_) and will communicate in two directions: service with database or, in the _logic_ layer, a component with other component.

=== Principles

The benefits of dividing our application in components are:

- https://en.wikipedia.org/wiki/Separation_of_concerns[Separation of concerns].

- https://en.wikipedia.org/wiki/Reusability[Reusability].

- Avoid https://en.wikipedia.org/wiki/Redundant_code[redundant code].

- https://en.wikipedia.org/wiki/Information_hiding[Information hiding].

- Self contained, descriptive and stable component APIs.

- Data consistency, a component is responsible for its data and changes to this data shall only happen via the component.

=== Naming

In _Oasp4j_, as a convention, we will name our components with the name of the target entity followed by `management` term.
----
Foomanagement
----

== OASP4j component example

_My Thai Star_ is an application of a restaurant that allows *booking* tables, and *order* different *dishes* so the main _Oasp4j_ components are:

image::images/oasp4j/4.Components/mythaistar_components.png[width="250", link="images/oasp4j/4.Components/mythaistar_components.png"]

- dishmanagement: This component will manage the dishes information retrieving it from the db and serving it to the client. It also could be used to create new menus.

- bookingmanagement: Manages the booking part of the application. With this component the users (anonymous/logged in) can create new reservations or cancel an existing reservation. The users with waiter role can see all scheduled reservations.

- ordermanagement: This component handles the process to order dishes (related to reservations). A user (as a host or as a guest) can create orders (that contain dishes) or cancel an existing one. The users with waiter role can see all ordered orders.

- usermanagement: Takes care of the User Profile management, allowing to create and update the data profiles.

Apart from that components we will have other _packages_ for the cross-cutting concerns:

- general: is a package that stores the common elements or configurations of the app, like _security_, _cxf services_ or _object mapping_ configurations.

- imagemanagement: in case of functionalities that will be used in several components, instead of duplicate the functionality (code) we can extract it to a component that the other components will consume. In the case of the images, as both _dishmanagement_ and _usermanagement_ components are going to need to manage images, this _imagecomponent_ will be used for that purpose.

- mailservice: with this service we will provide the functionality for sending email notifications. This is a shared service between different app components such as _bookingmanagement_ or _ordercomponent_.

=== OASP4j component structure

The component will be formed by one package for each one of the three layers that are defined by the _Oasp4j_ architecture: _service_, _logic_ and _dataaccess_.

image::images/oasp4j/4.Components/mythaistar_component_structure.png[width="250", link="images/oasp4j/4.Components/mythaistar_component_structure.png"]

- _Service_ Layer: will expose the REST api to exchange information with client applications.

- _Logic_ Layer: the layer in charge of hosting the business logic of the application.

- _Data Access_ Layer: the layer to communicate with the data base.

Apart from that the components will have a fourth package _common.api_ to store the common elements that will be used by the different layers of the component. This is the place will contain common _interfaces_, constants, exceptions or _enums_.

=== OASP4j component core

As we mentioned earlier, each component will be related to a functionality and this functionality will be represented in code by an _Entity_ that will define all the properties needed to wrap the logic of that feature.

This _Entity_, that represents the _core_ of the component, will be located in the `dataaccess.api` package.

The naming convention in _Oasp4j_ for these entities is

----
[Target]Entity
----

The 'Target' should match the name of the related table in the data base, although this is not mandatory.

image::images/oasp4j/4.Components/mythaistar_component_core1.png[width="250", link="images/oasp4j/4.Components/mythaistar_component_core1.png"]

Basically an _Entity_ is simply a https://en.wikipedia.org/wiki/Plain_old_Java_object[POJO] that will be mapped to a table in the data base, and that reflects each table column with a suitable property.

image::images/oasp4j/4.Components/mythaistar_component_core2.png[, link="images/oasp4j/4.Components/mythaistar_component_core2.png"]

== Create your components

After you have completed link:BuildOASP4Japplication[your own OASP4J app] creation, we are going to create our first app component.

Going back to our example application, link:JumpTheQueueDesign[Jump the Queue], we need to provide two basic functionalities:

- register a user (returning an access code).

- show the registered queue members.

To accomplish that we are going to work over two entities: _Visitor_ and _AccessCode_.

image::images/oasp4j/4.Components/visitor-accesscode.png[width="250", link="images/oasp4j/4.Components/visitor-accesscode.png"]

The _Visitor_ will be defined with: _name_, _email_ and _phone_.

The _Access Code_ will be represented as a _code_ and a _date_.

In addition, we will have to represent the https://en.wikipedia.org/wiki/One-to-one_(data_model)[one to one] relation between both entities.

Now is the moment to decide the components of our app. The complexity of the functionality would allow us to create only one component for managing both entities. But ,in order to clarify the example, we are going to create also two components, one for _Visitors_ and other for _Access Codes_.

[NOTE]
====
However if you feel more comfortable managing both entities in a single component you can also do it in that way. The results will be the same and the only difference will be related with the structure of the elements and the distribution of the code.
====

=== The data base

In the projects created with the _Oasp4j_ archetype, we already have a complete data base schema that we can use as a model to create our own. By default we are going to work over the http://www.h2database.com/html/main.html[H2] database engine provided in the _Oasp4j_ applications, although you can use other database alternatives for this exercise. 

Open the `/jumpthequeue-core/src/main/resources/db/migration/h2/V0001__R001_Create_schema.sql` and delete all the tables (except _BinaryObject_ and _RevInfo_, that are used internally by default).

==== _Visitor_ table

Now we can add our first table _Visitor_. In the case of _Jump the Queue_, the visitors will provide: _name_, _email_ and _phone_ to obtain an _access code_. So we need to represent that data in our table 

[source, sql]
----
CREATE TABLE Visitor(
  id BIGINT NOT NULL AUTO_INCREMENT,
  modificationCounter INTEGER NOT NULL,
  name VARCHAR(255),
  email VARCHAR(255),
  phone VARCHAR(255),
  idCode BIGINT,
  CONSTRAINT PK_Visitor PRIMARY KEY(id)
);
----

- _id_: the id for each visitor.

- _modificationCounter_: used internally by https://en.wikipedia.org/wiki/Java_Persistence_API[JPA] to take care of the https://en.wikipedia.org/wiki/Optimistic_concurrency_control[optimistic locking] for us.

- _name_: the visitor's name.

- _email_: the visitor's email.

- _phone_: the visitor's phone.

- _idCode_: the relation with the _Access Control_ entity represented with an id.

==== _Access Code_ table

As second table we will represent the _Access Code_ that will be formed by the _code_ itself and the related date. 

[source, sql]
----
CREATE TABLE AccessCode(
  id BIGINT NOT NULL AUTO_INCREMENT,
  modificationCounter INTEGER NOT NULL,
  code VARCHAR(5),
  dateAndTime TIMESTAMP,
  idVisitor BIGINT,
  CONSTRAINT PK_AccessCode PRIMARY KEY(id),
  CONSTRAINT FK_AccessCode_idVisitor FOREIGN KEY(idVisitor) REFERENCES Visitor(id)
);
----

- _id_: the id for each code.

- _modificationCounter_: used internally by https://en.wikipedia.org/wiki/Java_Persistence_API[JPA] to take care of the https://en.wikipedia.org/wiki/Optimistic_concurrency_control[optimistic locking] for us.

- _code_: the _access code_ that we are going to provide to the user after registration.

- _dateAndTime_: the date related to the _access code_.

- _idVisitor_: the relation with the _Visitor_ entity.


==== Mock data

Finally we can provide a certain amount of mock data to start our app. In the `/jumpthequeue-core/src/main/resources/db/migration/V0002__R001_Master_data.sql` script replace the current _inserts_ with ours

[source,sql]
----
INSERT INTO Visitor (id, modificationCounter, name, email, phone, idCode) VALUES (1, 1, 'Jason', 'jason@mail.com', '123456', 1);
INSERT INTO Visitor (id, modificationCounter, name, email, phone, idCode) VALUES (2, 1, 'Peter', 'peter@mail.com', '789101', 2);


INSERT INTO AccessCode (id, modificationCounter, code, dateAndTime, idVisitor) VALUES (1, 1, 'A01', CURRENT_TIMESTAMP + (60 * 60 * 24 * 5), 1);
INSERT INTO AccessCode (id, modificationCounter, code, dateAndTime, idVisitor) VALUES (2, 1, 'A02', CURRENT_TIMESTAMP + (60 * 60 * 24 * 5), 2);
----


=== The _core_ of the components

Now that we have defined the data base for our entities is the moment to start creating the code of the related components.

We are going to use _Cobigen_ to generate the component structure. That means that, as we already commented, we can generate all the structure and layers starting from a _core_ element: a simple _Plain Old Java Object_ that represents our _Entity_. So, in order to use _Cobigen_, we must create our entities in the expected location: `MyEntitymanagement.dataaccess.api`.

==== _Visitor_ component

To implement the component we will need to define a _VisitorEntity_ to connect and manage the data of the _Visitor_ table in the data base.

The name for this component will be `visitormanagement` and for the entity `VisitorEntity`.

From the root package of the project create the following packages:

----
- visitormanagement
-- dataaccess
--- api
---- 

image::images/oasp4j/4.Components/visitor_component_packages1.png[ link="images/oasp4j/4.Components/visitor_component_packages1.png"]

image::images/oasp4j/4.Components/visitor_component_packages2.png[width="450", link="images/oasp4j/4.Components/visitor_component_packages2.png"]

Now create a new java class in the just created `visitormanagement.dataaccess.api` package

image::images/oasp4j/4.Components/visitor_component_entity1.png[ link="images/oasp4j/4.Components/visitor_component_entity1.png"]

and call it _VisitorEntity_

image::images/oasp4j/4.Components/visitor_component_entity2.png[width="450", link="images/oasp4j/4.Components/visitor_component_entity2.png"]

In the entity, we are going to add the fields to represent the data model, so our entity should contain:

[source,java]
----
  private String name;
  
  private String email;
  
  private String phone;

  private AccessCodeEntity code;
----

[NOTE]
====
We are not adding the _id_ nor the _modificationCounter_ because _Cobigen_ will solve this for us.

The _AccessCodeEntity_ is throwing an error as it is not created yet. We will solve it in next step.
====

Now we need to declare our entity as a JPA entity with `@Entity` annotation (_javax.persistence.Entity_) at class level.

Also at class level, to map the entity with the database table, we will use the _@Table_ annotation (_javax.persistence.Table_) defining the name of our already created _Visitor_ table: `@Table(name = "Visitor")`

[source, java]
----
@Entity
@Table(name = "Visitor")
public class VisitorEntity
----

Now we have to declare the _getters_ and _setters_ of the fields of our entity. We can do it manually or using Eclipse with the option  

image::images/oasp4j/4.Components/visitor_component_gettersandsetters.png[ link="images/oasp4j/4.Components/visitor_component_gettersandsetters.png"]

To represent the _one to one_ relation with the _Access Control_ entity we must use the JPA annotations `@OneToOne` and `@JoinColumn` in the _getCode()_ method.

[source,java]
----
  @OneToOne(fetch = FetchType.EAGER, cascade = CascadeType.ALL)
  @JoinColumn(name = "idCode")
  public AccessCodeEntity getCode(){
      ...
  }
----

The result of current implementation for _VisitorEntity_ class is

[source,java]
----
package com.cap.jumpthequeue.visitormanagement.dataaccess.api;

import javax.persistence.CascadeType;
import javax.persistence.Entity;
import javax.persistence.FetchType;
import javax.persistence.JoinColumn;
import javax.persistence.OneToOne;
import javax.persistence.Table;

@Entity
@Table(name = "Visitor")
public class VisitorEntity {

  private String name;

  private String email;

  private String phone;

  private AccessCodeEntity code;

  /**
   * @return name
   */
  public String getName() {

    return this.name;
  }

  /**
   * @param name new value of {@link #getname}.
   */
  public void setName(String name) {

    this.name = name;
  }

  /**
   * @return email
   */
  public String getEmail() {

    return this.email;
  }

  /**
   * @param email new value of {@link #getemail}.
   */
  public void setEmail(String email) {

    this.email = email;
  }

  /**
   * @return phone
   */
  public String getPhone() {

    return this.phone;
  }

  /**
   * @param phone new value of {@link #getphone}.
   */
  public void setPhone(String phone) {

    this.phone = phone;
  }

  /**
   * @return code
   */
  @OneToOne(fetch = FetchType.EAGER, cascade = CascadeType.ALL)
  @JoinColumn(name = "idCode")
  public AccessCodeEntity getCode() {

    return this.code;
  }

  /**
   * @param code new value of {@link #getcode}.
   */
  public void setCode(AccessCodeEntity code) {

    this.code = code;
  }

}

----

[NOTE]
====
The compilation errors related to _AccessCodeEntity_ will be solved when we create the related entity in next step.
====

==== _AccessCode_ component

We are going to repeat the same process for the _AccessCode_ component. So we will end up with the following structure

image::images/oasp4j/4.Components/jumpthequeue_emptycomponents.png[ link="images/oasp4j/4.Components/jumpthequeue_emptycomponents.png"]

And the content of the _AccessCodeEntity_ before start using _Cobigen_ will be

[source,java]
----
package com.cap.jumpthequeue.accesscodemanagement.dataaccess.api;

import java.sql.Timestamp;

import javax.persistence.JoinColumn;
import javax.persistence.OneToOne;
import javax.persistence.Temporal;
import javax.persistence.TemporalType;

import com.cap.jumpthequeue.visitormanagement.dataaccess.api.VisitorEntity;

@Entity
@Table(name = "AccessCode")
public class AccessCodeEntity {

  private String code;

  @Temporal(TemporalType.TIMESTAMP)
  private Timestamp dateAndTime;

  private VisitorEntity visitor;

  /**
   * @return code
   */
  public String getCode() {

    return this.code;
  }

  /**
   * @param code new value of {@link #getcode}.
   */
  public void setCode(String code) {

    this.code = code;
  }

  /**
   * @return dateAndTime
   */
  public Timestamp getDateAndTime() {

    return this.dateAndTime;
  }

  /**
   * @param dateAndTime new value of {@link #getdateAndTime}.
   */
  public void setDateAndTime(Timestamp dateAndTime) {

    this.dateAndTime = dateAndTime;
  }

  /**
   * @return visitor
   */
  @OneToOne
  @JoinColumn(name = "idVisitor")
  public VisitorEntity getVisitor() {

    return this.visitor;
  }

  /**
   * @param visitor new value of {@link #getvisitor}.
   */
  public void setVisitor(VisitorEntity visitor) {

    this.visitor = visitor;
  }

}
----

With this we have finished preparing the core of our components. Now we can start using _Cobigen_ to generate all the remaining structure (services, layers, dao's, etc.).

=== The component's structure with _Cobigen_

Once we have finished creating the _core_ of our components we could continue creating all the structure and elements manually, but we are going to show how using _Cobigen_ for those tasks we can save a significant amount of time and effort.

==== Importing Cobigen templates

Before start using _Cobigen_ we need to import into our project the _CobiGenTemplates_. To do so, we only need to use the Eclipse's menu _File > Import > Existing Projects into Workspace_ and browse to select the `workspaces/main/CobiGen_Templates` directory. Then click _Finish_ button and you should have the _CobiGenTemplates_ as a new project in Eclipse's workspace.

image::images/oasp4j/4.Components/cobigen_templates.png[width="250", link="images/oasp4j/4.Components/cobigen_templates.png"]


==== Cobigen Health Check

The first time we use Cobigen is recommended to check the health of the tool. To do so, right-click over an entity and select _Health Check_

image::images/oasp4j/4.Components/cobigen0.png[link="images/oasp4j/4.Components/cobigen0.png"]

The next dialogs will show us if there are outdated templates. In that case we can solve it clicking the _Update_ button.

image::images/oasp4j/4.Components/cobigen_health1.png[width="350",link="images/oasp4j/4.Components/cobigen_health1.png"]

image::images/oasp4j/4.Components/cobigen_health2.png[width="350",link="images/oasp4j/4.Components/cobigen_health2.png"]

==== _Visitor_ component structure

To create the whole structure of a component with _Cobigen_ we only need to right-clicking over our component core entity, select _Cobigen > Generate_

image::images/oasp4j/4.Components/cobigen1.png[link="images/oasp4j/4.Components/cobigen1.png"]

Now we have to choose which packages we want to generate with the tool.

The options are:

* _CRUD DAO's_: generates the implementation of CRUD operations in the data access layer.

image::images/oasp4j/4.Components/cobigen2_crud_dao.png[link="images/oasp4j/4.Components/cobigen2_crud_dao.png"]

* _CRUD REST services_: generates a complete service layer with CRUD operations for our entity exposed as a REST service.

image::images/oasp4j/4.Components/cobigen2_crud_rest.png[link="images/oasp4j/4.Components/cobigen2_crud_rest.png"]

* _CRUD logic (with use cases)_: generates the logic layer dividing the implementation in different use cases.

image::images/oasp4j/4.Components/cobigen2_crud_logic_withusecases.png[link="images/oasp4j/4.Components/cobigen2_crud_logic_withusecases.png"]

* _CRUD logic (all in one)_: does the same as previous option but with the implementation of the logic layer in only one class instead of different use-cases classes.

image::images/oasp4j/4.Components/cobigen2_crud_logic_allinone.png[link="images/oasp4j/4.Components/cobigen2_crud_logic_allinone.png"]

* _Entity infrastructure_: creates the entity main interface and edits (by a merge) the current entity to extend the oasp classes

image::images/oasp4j/4.Components/cobigen2_entityinfrastructure.png[link="images/oasp4j/4.Components/cobigen2_entityinfrastructure.png"]

* _TO's_: generates the related _Transfer Objects_ that we will explain in next chapters of this tutorial

image::images/oasp4j/4.Components/cobigen2_tos.png[link="images/oasp4j/4.Components/cobigen2_tos.png"]

To generate all the needed functionalities of our component we are going to select the following packages to be generated *at the same time*

image::images/oasp4j/4.Components/cobigen3_allpackages.png[link="images/oasp4j/4.Components/cobigen3_allpackages.png"]

Now we can select the fields to be involved (all by default) or directly create all the packages clicking the _Finish_ button.

During the process _Cobigen_ will show a message asking us to review some ambiguous references. Click _Continue_

image::images/oasp4j/4.Components/cobigen4_review_imports.png[link="images/oasp4j/4.Components/cobigen4_review_imports.png"]

Once _Cobigen_ has finished we will check if we need to introduce manual adjustments. In the case of the _Visitor_ component, we have a relation (dependency) with some of the _Access Code_ component elements, that are still not created. We will solve this compilation errors in next step.

image::images/oasp4j/4.Components/cobigen5_expected_errors.png[link="images/oasp4j/4.Components/cobigen5_expected_errors.png"]

==== _Access Code_ component structure

Now we are going to repeat the same process using _Cobigen_ with our other _AccessCode_ component.

Once the process has finished you may see that we need to also adjust manually some imports related to _Timestamp_ type in:

- `accesscodemanagement/common/api/AccessCode.java`

- `accesscodemanagement/logic/api/to/AccessCodeSearchCriteriaTo.java`

- `accesscodemanagement/dataaccess/impl/dao/AccessCodeDaoImpl.java`

- `accesscodemanagement/logic/api/to/AccessCodeEto.java`

Solve it manually using the Eclipse helpers and finally go to `visitormanagement/logic/api/to/VisitorCto.java` and resolve our last compilation error related to `AccessCodeEto`, that has been already created.

==== Run the app

If all compilation errors are solved run the app ( _SpringBootApp.java right click > Run as > Java application_ ). The app should be launched without errors.

Congratulations you have created your first _Oasp4j_ components. In the next chapter we will explain and show in detail each of the created elements

=== link:OASP4jLayers[Next chapter: Oasp4j Layers]